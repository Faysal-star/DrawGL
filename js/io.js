import { state } from './state.js';
import { sanitizeName } from './utils.js';

export function saveToStorage(projectNameInput) {
    const projectName = projectNameInput.value || 'untitled_project';
    const savedProjects = JSON.parse(localStorage.getItem('glforge_projects') || '{}');

    savedProjects[projectName] = {
        shapes: state.shapes,
        groups: state.groups,
        settings: state.settings,
        savedAt: new Date().toISOString()
    };

    localStorage.setItem('glforge_projects', JSON.stringify(savedProjects));
    localStorage.setItem('glforge_current', projectName);

    // Note: Toast should be handled by UI layer, IO should probably return success/fail or just do the logic
    return true;
}

export function loadFromStorage(projectName, uiCallbacks) {
    const savedProjects = JSON.parse(localStorage.getItem('glforge_projects') || '{}');
    const project = savedProjects[projectName];

    if (project) {
        state.shapes = project.shapes || [];
        state.groups = project.groups || [];
        if (project.settings) {
            // Fix for theme migration: if the saved color is the old default red, update to new teal
            if (project.settings.defaultColor && (project.settings.defaultColor.toLowerCase() === '#e94560')) {
                project.settings.defaultColor = '#10b981';
            }
            Object.assign(state.settings, project.settings);
        }
        return true;
    }
    return false;
}

export function loadCurrentProject() {
    const currentProject = localStorage.getItem('glforge_current');
    if (!currentProject) return null;
    return currentProject;
}

export function getSavedProjects() {
    return JSON.parse(localStorage.getItem('glforge_projects') || '{}');
}

export function deleteProject(projectName) {
    const savedProjects = JSON.parse(localStorage.getItem('glforge_projects') || '{}');
    delete savedProjects[projectName];
    localStorage.setItem('glforge_projects', JSON.stringify(savedProjects));
}

export function downloadProjectFile(projectName) {
    const projectData = {
        shapes: state.shapes,
        groups: state.groups,
        settings: state.settings,
        savedAt: new Date().toISOString(),
        version: '1.0'
    };

    const jsonString = JSON.stringify(projectData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${projectName}.drawgl.json`;
    a.click();
    URL.revokeObjectURL(url);
}

export function loadFromFile(file, callback) {
    const reader = new FileReader();
    
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            
            // Validate the data structure
            if (!projectData.shapes || !Array.isArray(projectData.shapes)) {
                callback({ success: false, error: 'Invalid file format: missing shapes array' });
                return;
            }
            
            // Load the data into state
            state.shapes = projectData.shapes || [];
            state.groups = projectData.groups || [];
            if (projectData.settings) {
                // Fix for theme migration
                if (projectData.settings.defaultColor && projectData.settings.defaultColor.toLowerCase() === '#e94560') {
                    projectData.settings.defaultColor = '#10b981';
                }
                Object.assign(state.settings, projectData.settings);
            }
            
            callback({ success: true });
        } catch (error) {
            callback({ success: false, error: 'Failed to parse file: ' + error.message });
        }
    };
    
    reader.onerror = () => {
        callback({ success: false, error: 'Failed to read file' });
    };
    
    reader.readAsText(file);
}

export function generateExport(namespace, filename, options) {
    const includeComments = options.includeComments;
    const includeColors = options.includeColors;

    let code = '';

    // Header comment
    if (includeComments) {
        code += `// ${filename}\n`;
        code += `// Generated by DrawGL (github.com/faysal-star/DrawGL)\n`;
        code += `// ${new Date().toISOString()}\n`;
        code += `// Modern OpenGL 3.3+ Compatible\n\n`;
    }

    const guard = namespace.toUpperCase() + '_H';
    code += `#ifndef ${guard}\n`;
    code += `#define ${guard}\n\n`;

    // Includes
    code += `#include <glad/glad.h>\n`;
    code += `#include <unordered_map>\n`;
    code += `#include <string>\n\n`;

    code += `namespace ${namespace} {\n\n`;

    // Generate vertex data for each shape with interleaved position + color
    state.shapes.forEach(shape => {
        const name = sanitizeName(shape.name);
        const r = parseInt(shape.color.substr(1, 2), 16) / 255;
        const g = parseInt(shape.color.substr(3, 2), 16) / 255;
        const b = parseInt(shape.color.substr(5, 2), 16) / 255;

        if (includeComments) {
            code += `    // --- Shape: ${shape.name} (${shape.primitiveType}, ${shape.vertices.length} vertices) ---\n`;
        }

        // Interleaved vertex data: x, y, r, g, b, a
        code += `    const float ${name}_vertices[] = {\n`;
        if (includeComments) {
            code += `        // x,       y,       r,       g,       b,       a\n`;
        }
        shape.vertices.forEach((v, i) => {
            const comma = i < shape.vertices.length - 1 ? ',' : '';
            if (includeColors) {
                code += `        ${v.x.toFixed(4)}f, ${v.y.toFixed(4)}f, ${r.toFixed(4)}f, ${g.toFixed(4)}f, ${b.toFixed(4)}f, 1.0f${comma}\n`;
            } else {
                code += `        ${v.x.toFixed(4)}f, ${v.y.toFixed(4)}f, 1.0f, 1.0f, 1.0f, 1.0f${comma}\n`;
            }
        });
        code += `    };\n`;
        code += `    const int ${name}_count = ${shape.vertices.length};\n`;
        code += `    const GLenum ${name}_primitive = ${shape.primitiveType};\n\n`;
    });

    // ShapeData struct
    if (includeComments) {
        code += `    // --- Shape data structure for runtime management ---\n`;
    }
    code += `    struct ShapeData {\n`;
    code += `        const float* vertices;\n`;
    code += `        int count;\n`;
    code += `        GLenum primitive;\n`;
    code += `        unsigned int VAO = 0;\n`;
    code += `        unsigned int VBO = 0;\n`;
    code += `    };\n\n`;

    // Shape registry function
    if (includeComments) {
        code += `    // --- Shape registry (lazy-initialized singleton) ---\n`;
    }
    code += `    inline std::unordered_map<std::string, ShapeData>& getShapes() {\n`;
    code += `        static std::unordered_map<std::string, ShapeData> shapes = {\n`;
    state.shapes.forEach((shape, i) => {
        const name = sanitizeName(shape.name);
        const comma = i < state.shapes.length - 1 ? ',' : '';
        code += `            {"${name}", {${name}_vertices, ${name}_count, ${name}_primitive}}${comma}\n`;
    });
    code += `        };\n`;
    code += `        return shapes;\n`;
    code += `    }\n\n`;

    // initShape function
    if (includeComments) {
        code += `    // --- Initialize VAO/VBO for a single shape ---\n`;
    }
    code += `    inline void initShape(const std::string& name) {\n`;
    code += `        auto& shapes = getShapes();\n`;
    code += `        auto it = shapes.find(name);\n`;
    code += `        if (it == shapes.end()) return;\n`;
    code += `        ShapeData& s = it->second;\n`;
    code += `        if (s.VAO != 0) return; // Already initialized\n\n`;
    code += `        glGenVertexArrays(1, &s.VAO);\n`;
    code += `        glGenBuffers(1, &s.VBO);\n`;
    code += `        glBindVertexArray(s.VAO);\n`;
    code += `        glBindBuffer(GL_ARRAY_BUFFER, s.VBO);\n`;
    code += `        glBufferData(GL_ARRAY_BUFFER, s.count * 6 * sizeof(float), s.vertices, GL_STATIC_DRAW);\n\n`;
    code += `        // Position attribute (location = 0)\n`;
    code += `        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);\n`;
    code += `        glEnableVertexAttribArray(0);\n\n`;
    code += `        // Color attribute (location = 1)\n`;
    code += `        glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(2 * sizeof(float)));\n`;
    code += `        glEnableVertexAttribArray(1);\n\n`;
    code += `        glBindVertexArray(0);\n`;
    code += `    }\n\n`;

    // initAllShapes function
    if (includeComments) {
        code += `    // --- Initialize all shapes ---\n`;
    }
    code += `    inline void initAllShapes() {\n`;
    code += `        for (auto& pair : getShapes()) {\n`;
    code += `            initShape(pair.first);\n`;
    code += `        }\n`;
    code += `    }\n\n`;

    // drawShape function
    if (includeComments) {
        code += `    // --- Draw a single shape by name ---\n`;
    }
    code += `    inline void drawShape(const std::string& name) {\n`;
    code += `        auto& shapes = getShapes();\n`;
    code += `        auto it = shapes.find(name);\n`;
    code += `        if (it == shapes.end()) return;\n`;
    code += `        ShapeData& s = it->second;\n`;
    code += `        if (s.VAO == 0) initShape(name);\n`;
    code += `        glBindVertexArray(s.VAO);\n`;
    code += `        glDrawArrays(s.primitive, 0, s.count);\n`;
    code += `    }\n\n`;

    // drawAll function
    if (includeComments) {
        code += `    // --- Draw all shapes ---\n`;
    }
    code += `    inline void drawAll() {\n`;
    code += `        for (auto& pair : getShapes()) {\n`;
    code += `            drawShape(pair.first);\n`;
    code += `        }\n`;
    code += `    }\n\n`;

    // cleanup function
    if (includeComments) {
        code += `    // --- Cleanup all GPU resources ---\n`;
    }
    code += `    inline void cleanup() {\n`;
    code += `        for (auto& pair : getShapes()) {\n`;
    code += `            ShapeData& s = pair.second;\n`;
    code += `            if (s.VAO) {\n`;
    code += `                glDeleteVertexArrays(1, &s.VAO);\n`;
    code += `                s.VAO = 0;\n`;
    code += `            }\n`;
    code += `            if (s.VBO) {\n`;
    code += `                glDeleteBuffers(1, &s.VBO);\n`;
    code += `                s.VBO = 0;\n`;
    code += `            }\n`;
    code += `        }\n`;
    code += `    }\n\n`;

    code += `} // namespace ${namespace}\n\n`;
    code += `#endif // ${guard}\n`;

    return code;
}
